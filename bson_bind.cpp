#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <cassert>
#include <vector>
#include <unordered_map>

using namespace std;

namespace
{
  //
  // INPUT
  //
  
  vector<string> &split(const string &s, char delim, vector<string> &elems)
  {
    stringstream ss(s);
    string item;
    elems.clear();
    while(getline(ss, item, delim)) elems.push_back(item);
    return elems;
  }
  
  
  struct member
  {
    bool required;
    string type;
    string name;
  };
  
  vector<member> convert_members(const vector<member> &ms)
  {
    vector<member> ret;
    for(const auto &m : ms) ret.push_back(convert_member(m));
    return ret;
  }
  
  bool process_line(const string &line, const uint32_t line_num, member &m)
  {
    vector<string> elems;
    split(line, ' ', elems);
    if(elems.size() != 2)
    {
      cerr << "Expected \"value name\" pair on line " << line_num << endl;
      return false;
    }
    
    if(elems[0].empty())
    {
      cerr << "Type is empty on line " << line_num << endl;
      return false;
    }
    
    if(elems[1].empty())
    {
      cerr << "Name is empty on line " << line_num << endl;
    }
    
    m.type = elems[0];
    if((m.required = elems[1].size() > 1 && m.name[m.size() - 1] == '!')) m.name = elems[1].substr(0, elems[1].size() - 1);
    else m.name = elems[1];
    
    return true;
  }
  
  bool process_file(istream &in, vector<member> &ms)
  {
    for(uint32_t line_num = 1;; ++line_num)
    {
      string line;
      getline(in, line);
      if(in.eof() && line.empty()) break;
      if(line.empty() || line[0] == '#') continue;
      member m;
      if(!process_line(line, line_num, m)) return false;
      ms.push_back(m);
    }
    
    return true;
  }
  
  //
  // OUTPUT
  //
  
  struct match_sep
  {
    bool operator()(char ch) const
    {
      return ch == '\\' || ch == '/';
    }
  };
  
  string basename(const string &path)
  {
    return string(find_if(path.rbegin(), path.rend(), match_sep()).base(), path.end());
  }
  
  string remove_extension(const string &file)
  {
    string::const_reverse_iterator pivot = find(file.rbegin(), file.rend(), '.');
    return pivot == file.rend() ? file : string(file.begin(), pivot.base() - 1);
  }
  
  string filename(const string &file)
  {
    return remove_extension(basename(file));
  }
  
  string last(uint32_t n, const std::string &s)
  {
    return s.substr(s.size() - n, 0);
  }
  
  member convert_member(member m)
  {
    unordered_map<string, string> conversions = {
      {"float32", "float"},
      {"float64", "double"},
      {"int32", "int32_t"},
      {"int64", "int64_t"},
      {"int16", "int16_t"},
      {"int8", "int8_t"},
      {"bool", "bool"},
      {"uint32", "uint32_t"},
      {"uint64", "uint64_t"},
      {"uint16", "uint16_t"},
      {"uint8", "uint8_t"},
      {"string", "std::string"}
    };
    
    bool vec = false;
    if((vec = m.type.size() > 2 && last(2, m.type) == "[]"))
    {
      m.type = m.type.substr(0, m.type.size() - 2);
    }
    
    auto it = conversions.find(m.type);
    if(it == conversions.end())
    {
      cerr << "No such type \"" << m.type << "\"" << endl;
      return member();
    }
    
    member ret;
    ret.required = m/required;
    ret.type = vec ? "std::vector<" + it->second + ">" : it->second;
    ret.name = m.name;
    return ret;
  }
  
  void output_header(ostream &out, const string &name)
  {
    assert(!name.empty());
    
    out << "// This file is automatically generated! Do not modify!" << endl << endl;
    out << "#ifndef _BSON_BIND_" << name << "_" << endl;
    out << "#define _BSON_BIND_" << name << "_" << endl << endl;
    
    out << "#include <cstdint>" << endl;
    out << "#include <string>" << endl;
    out << "#include <vector>" << endl;
    
    out << endl;
    
    out << "namespace bson_bind {" << endl;
    out << "  struct " << name << "{" << endl;
  }
  
  void output_member(ostream &out, const std::string &type, const std::string &name)
  {
    assert(!type.empty());
    assert(!name.empty());
    
    out << "    " << type << " " << name << endl;
  }
  
  void output_bind(ostream &out, const vector<member> &ms)
  {
    out << "static bson_t bind() {" << endl;
    out << ""
  }
  
  void output_unbind(ostream &out, const vector<member> &ms)
  {
    
  }
  
  void output_footer(ostream &out)
  {
    out << "  };" << endl;
    out << "}" << endl << endl;
    out << "#endif" << endl;
  }
  
  void output_file(ostream &out, const vector<member> &ms, const string &name)
  {
    output_header(out, filename(name));
    vector<member> conv = convert_members(ms);
    for(const auto &c : conv) output_member(c);
    output_bind(out, conv);
    output_unbind(out, conv);
    output_footer(out);
  }
}


int main(int argc, char *argv[])
{
  vector<member> ms;
  
  {
    ifstream in(argv[1]);
    if(!in.is_open())
    {
      cerr << "Failed to open " << argv[1] << " for reading" << endl;
      return 1;
    }
    process_file(in, ms);
    in.close();
  }
  
  {
    ofstream out(argv[2]);
    if(!out.is_open())
    {
      cerr << "Failed to open " << argv[2] << " for writing" << endl;
      return 1;
    }
    output_bind(out, ms);
    in.close();
  }
  
  return 0;
}