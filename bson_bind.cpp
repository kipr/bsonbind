#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <cassert>
#include <vector>
#include <unordered_map>
#include <stdexcept>

using namespace std;

namespace
{
  //
  // INPUT
  //
  
  vector<string> &split(const string &s, char delim, vector<string> &elems)
  {
    stringstream ss(s);
    string item;
    elems.clear();
    while(getline(ss, item, delim)) elems.push_back(item);
    return elems;
  }
  
  
  struct member
  {
    bool vec;
    bool required;
    string type;
    string name;
  };
  
  struct conv_member
  {
    bool required;
    bool vec;
    string type;
    string name;
  };
  
  bool process_line(const string &line, const uint32_t line_num, member &m)
  {
    vector<string> elems;
    split(line, ' ', elems);
    if(elems.size() != 2)
    {
      cerr << "Expected \"value name\" pair on line " << line_num << endl;
      return false;
    }
    
    if(elems[0].empty())
    {
      cerr << "Type is empty on line " << line_num << endl;
      return false;
    }
    
    if(elems[1].empty())
    {
      cerr << "Name is empty on line " << line_num << endl;
    }
    
    m.type = elems[0];
    if((m.required = elems[1].size() > 1 && elems[1].back() == '!')) elems[1] = elems[1].substr(0, elems[1].size() - 1);
    if((m.vec = elems[1].size() > 2 && elems[1].substr(elems[1].size() - 2) == "[]")) elems[1] = elems[1].substr(0, elems[1].size() - 2);
    m.name = elems[1];
    
    return true;
  }
  
  bool process_file(istream &in, vector<member> &ms)
  {
    for(uint32_t line_num = 1;; ++line_num)
    {
      string line;
      getline(in, line);
      if(in.eof() && line.empty()) break;
      if(line.empty() || line[0] == '#') continue;
      member m;
      if(!process_line(line, line_num, m)) return false;
      ms.push_back(m);
    }
    
    return true;
  }
  
  //
  // OUTPUT
  //
  
  struct match_sep
  {
    bool operator()(char ch) const
    {
      return ch == '\\' || ch == '/';
    }
  };
  
  string basename(const string &path)
  {
    return string(find_if(path.rbegin(), path.rend(), match_sep()).base(), path.end());
  }
  
  string remove_extension(const string &file)
  {
    string::const_reverse_iterator pivot = find(file.rbegin(), file.rend(), '.');
    return pivot == file.rend() ? file : string(file.begin(), pivot.base() - 1);
  }
  
  string filename(const string &file)
  {
    return remove_extension(basename(file));
  }
  
  string last(const uint32_t n, const std::string &s)
  {
    return s.substr(s.size() - n);
  }
  
  conv_member convert_member(member m)
  {
    unordered_map<string, string> conversions = {
      {"real32", "float"},
      {"real64", "double"},
      {"int32", "int32_t"},
      {"int16", "int16_t"},
      {"int8", "int8_t"},
      {"bool", "bool"},
      {"uint32", "uint32_t"},
      {"uint16", "uint16_t"},
      {"uint8", "uint8_t"},
      {"string", "std::string"}
    };
    
    auto it = conversions.find(m.type);
    if(it == conversions.end())
    {
      cerr << "No such type \"" << m.type << "\"" << endl;
      return conv_member();
    }
    
    conv_member ret;
    ret.required = m.required;
    ret.vec = m.vec;
    ret.type = it->second;
    ret.name = m.name;
    return ret;
  }
  
  vector<conv_member> convert_members(const vector<member> &ms)
  {
    vector<conv_member> ret;
    for(const auto &m : ms) ret.push_back(convert_member(m));
    return ret;
  }
  
  void output_header(ostream &out, const string &name)
  {
    assert(!name.empty());
    
    out << "// This file is automatically generated! Do not modify!" << endl << endl;
    out << "#ifndef _BSON_BIND_" << name << "_" << endl;
    out << "#define _BSON_BIND_" << name << "_" << endl << endl;
    
    out << "#include <cstdint>" << endl;
    out << "#include <string>" << endl;
    out << "#include <vector>" << endl;
    out << "#include <bson.h>" << endl;
    
    out << endl;
    
    out << "namespace bson_bind {" << endl;
    out << "  struct " << name << " {" << endl;
  }
  
  void output_member(ostream &out, const conv_member &m)
  {
    assert(!m.type.empty());
    assert(!m.name.empty());
    
    out << "    " << (m.vec ? "std::vector<" + m.type + ">" : m.type) << " " << m.name << ";" << endl;
  }
  
  string bson_append_primitive(conv_member m, const string key_override = string(), const string value_override = string())
  {
    stringstream out;
    if(!value_override.empty()) m.name = value_override;
    if(m.type == "std::string")
    {
      out << "bson_append_utf8(ret, " << (key_override.empty() ? "\"" + m.name + "\"" : key_override) <<", -1, " << m.name << ".c_str(), -1);";
    }
    else
    {
      if(m.type[0] == 'i' || m.type[0] == 'u') out << "bson_append_int32";
      else if(m.type == "bool") out << "bson_append_bool";
      else if(m.type == "float" || m.type == "double") out << "bson_append_double";
      out << "(ret, " << (key_override.empty() ? "\"" + m.name + "\"" : key_override) << ", -1, " << m.name << ");";
    }
    return out.str();
  }
  
  string bson_type_check(const conv_member &m, bool vec_check, bool negate)
  {
    stringstream out;
    out << "if(v->value_type " << (negate ? "!=" : "==") << " ";
    if(vec_check && m.vec)
    {
      out << "BSON_TYPE_ARRAY";
    }
    else if(m.type == "std::string")
    {
      out << "BSON_TYPE_UTF8";
    }
    else
    {
      if(m.type[0] == 'i' || m.type[0] == 'u') out << "BSON_TYPE_INT32";
      else if(m.type == "bool") out << "BSON_TYPE_BOOL";
      else if(m.type == "float" || m.type == "double") out << "BSON_TYPE_DOUBLE";
    }
    out << ")";
    return out.str();
  }
  
  string bson_read_primitive(conv_member m, const string &name_override = string())
  {
    if(!name_override.empty()) m.name = name_override;
    stringstream out;
    if(m.type == "std::string")
    {
      out << m.name << " = std::string(v->value.v_utf8.str, v->value.v_utf8.len);";
    }
    else
    {
      if(m.type[0] == 'i' || m.type[0] == 'u') out << m.name << " = v->value.v_int32;";
      else if(m.type == "bool") out << m.name << " = v->value.v_bool;";
      else if(m.type == "float" || m.type == "double") out << m.name << " = v->value.v_double;";
    }
    return out.str();
  }
  
  void output_bind(ostream &out, const vector<conv_member> &ms)
  {
    out << "    bson_t *bind() {" << endl
        << "      bson_t *ret = bson_new();" << endl
        << "      bson_t *arr;" << endl
        << "      uint32_t i = 0;" << endl;
    for(const auto &m : ms)
    {
      if(m.vec)
      {
        out << "      arr = bson_new();" << endl
            << "      i = 0;" << endl
            << "      for(vector<" << m.type << ">::const_iterator it = " << m.name << ".begin();" << endl
            << "          it != " << m.name << ".end(); ++it, ++i)" << endl
            << "        " << bson_append_primitive(m, "std::to_string(i).c_str()", "(*it)") << endl
            << "      bson_append_document(ret, \"" << m.name << "\", -1, arr);" << endl
            << "      bson_destroy(arr);";
      }
      else
      {
        out << "      " << bson_append_primitive(m);
      }
      out << endl;
    }
    out << "      return ret;" << endl
        << "    }" << endl;
  }
  
  void output_unbind(ostream &out, const vector<conv_member> &ms, const std::string &name)
  {
    out << "    static " << name << " unbind(const bson_t *const bson) {" << endl
        << "      bson_iter_t it;" << endl
        << "      bson_iter_t itt;" << endl
        << "      uint32_t i = 0;" << endl
        << "      bool found;" << endl
        << "      const bson_value_t *v;" << endl
        << "      bson_t *arr;" << endl
        << "      " << name << " ret;" << endl;
    for(const auto &m : ms)
    {
      out << "      found = bson_iter_init_find(&it, bson, \"" << m.name << "\");" << endl;
      if(m.required)
      {
        out << "      if(!found) throw std::invalid_argument(\"required key " << m.name << " not found in bson document\");" << endl
            << "      else {" << endl;
      }
      else
      {
        out << "      if(found) {" << endl;
      }
      out << "        v = bson_iter_value(&it);" << endl
          << "        " << bson_type_check(m, true,  true) << " throw std::invalid_argument(\"key " << m.name << " has the wrong type\");" << endl;
      if(m.vec)
      {
        out << "        arr = bson_new_from_data(v->value.v_doc.data, v->value.v_doc.data_len);" << endl
            << "        i = 0;" << endl
            << "        for(;; ++i) {" << endl
            << "          if(!bson_iter_init_find(&itt, arr, std::to_string(i).c_str())) break;" << endl
            << "          v = bson_iter_value(&itt);" << endl
            << "          " << bson_type_check(m, false, true) << " throw std::invalid_argument(\"key " << m.name << " has the wrong type\");" << endl
            << "          " << m.type << " tmp;" << endl
            << "          " << bson_read_primitive(m, "tmp") << endl
            << "          ret." << m.name << ".push_back(tmp);" << endl
            << "        }" << endl
            << "        bson_destroy(arr);" << endl;
      }
      else
      {
        out << "        ret." << bson_read_primitive(m) << endl;
      }
      out << "      }" << endl;
    }
    out << "      return ret;" << endl
        << "    }" << endl;
  }
  
  void output_footer(ostream &out)
  {
    out << "  };" << endl;
    out << "}" << endl << endl;
    out << "#endif" << endl;
  }
  
  void output_file(ostream &out, const vector<member> &ms, const string &name)
  {
    const auto realname = filename(name);
    output_header(out, realname);
    const auto conv = convert_members(ms);
    for(const auto &c : conv) output_member(out, c);
    output_bind(out, conv);
    output_unbind(out, conv, realname);
    output_footer(out);
  }
}


int main(int argc, char *argv[])
{
  vector<member> ms;
  if(argc != 3)
  {
    cout << argv[0] << " input.bsonbind output.hpp" << endl;
    return 1;
  }
  
  {
    ifstream in(argv[1]);
    if(!in.is_open())
    {
      cerr << "Failed to open " << argv[1] << " for reading" << endl;
      return 1;
    }
    process_file(in, ms);
    in.close();
  }
  
  {
    ofstream out(argv[2]);
    if(!out.is_open())
    {
      cerr << "Failed to open " << argv[2] << " for writing" << endl;
      return 1;
    }
    output_file(out, ms, argv[2]);
    out.close();
  }
  
  return 0;
}